package com.cor.graphx.util

import com.cor.graphx.handler.FlickrTwitterEventHandler

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import com.cor.graphx.event.Tweet
import com.cor.graphx.event.TwitterUser
import org.apache.spark.graphx.Edge

import org.apache.spark.graphx.VertexId
import scala.collection.mutable.ListBuffer
import com.cor.graphx.event.Hashtag
import com.cor.graphx.event.FlickrUser
import com.cor.graphx.event.Photo



object EventGenerator extends App{

  /**
   * Creates events and lets the implementation class handle them.
   */
  def startSendingEvents(eventHandler: FlickrTwitterEventHandler): Unit = {

    val numInactiveTwitterUsers = 1000
    val numInfluencerTwitterUsers = 5
    val numActiveTwitterUsers = 100
    val numFlickrUsers = 1000
    val numHashtags = 50

    // Edges
    val avgNumFollowersPerUser = 60 //40
    val avgNumFollowersPerInfluencer = 40000
    val avgNumFollowersPerFlickrUser = 50 //40
    val avgNumPhotoPerUser = 10
    val avgNumTweetPerUser = 10 //4
    val avgNumTweetPerInfluencer = 100
    val avgNumHashtagsPerTweet = 2
    val avgNumLikesPerTweet = 20
    val avgNumMentionsInTweet = 1
    val avgNumFavoritesPerPhoto = 50
    val avgNumCommentsPerPhoto = 2
    var hashtags = new ListBuffer[Hashtag]()
    val logger: Logger = LoggerFactory.getLogger(getClass)
    

    logger.info(getStartingMessage())
    
    var count = 0
    var p = 0
    for (p <- 1 to numHashtags) {
      val ht = new Hashtag(count, System.currentTimeMillis(), "hashtag" + p)
      eventHandler.handleVertex(ht)
      hashtags += ht
      count += 1
    }
    
    while (true) {

      val tu = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + count, "twitterUser" + count, "malaga", "false", "", "", "user" + count + "description", System.currentTimeMillis())
      eventHandler.handleVertex(tu)
      count += 1

      val rand = scala.util.Random
      val numTweets = rand.nextInt(avgNumTweetPerUser * 2)
      val it = 0
      for (it <- 1 to numTweets) {
        val t = new Tweet(count, System.currentTimeMillis(), "tweet-" + tu.id + "-" + it, "tweet text", System.currentTimeMillis(), "web")
        eventHandler.handleVertex(t)
        val edge = Edge(tu.idNode.asInstanceOf[VertexId], t.idNode.asInstanceOf[VertexId], (ListBuffer("publishes"), 0L))
        eventHandler.handleEdge(edge)
        count += 1

        val numHashtagsThisTweet = rand.nextInt(avgNumHashtagsPerTweet * 2)
        val i = 0
        for (i <- 1 to numHashtagsThisTweet) {
          val htn = rand.nextInt(hashtags.size)
          val ht = hashtags(htn)
          val edge = Edge(t.idNode.asInstanceOf[VertexId], ht.idNode.asInstanceOf[VertexId], (ListBuffer("contains"), 0L))
          eventHandler.handleEdge(edge)
        }

        val numLikesThisTweet = rand.nextInt(avgNumLikesPerTweet * 2)
        val itLike = 0
        for (itLike <- 1 to numLikesThisTweet) {
          val tuLike = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + count, "twitterUser" + count, "malaga", "false", "", "", "user" + count + "description", System.currentTimeMillis())
          eventHandler.handleVertex(tuLike)
          val like = Edge(tuLike.idNode.asInstanceOf[VertexId], t.idNode.asInstanceOf[VertexId], (ListBuffer("likes"), System.currentTimeMillis()))
          eventHandler.handleEdge(like)
          count += 1
        }
		
      }

      val numFollowers = rand.nextInt(avgNumFollowersPerUser * 2)
      val it2 = 0
      for (it2 <- 1 to numFollowers) {
        val tu1 = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + count, "twitterUser" + count, "malaga", "false", "", "", "user" + count + "description", System.currentTimeMillis())
        eventHandler.handleVertex(tu1)
        val edge = Edge(tu1.idNode.asInstanceOf[VertexId], tu.idNode.asInstanceOf[VertexId], (ListBuffer("follows"), 0L)) //tu1 follows tu
        eventHandler.handleEdge(edge)
        count += 1

        val it = 0
        for (it <- 1 to numTweets) {
          val t = new Tweet(count, System.currentTimeMillis(), "tweet-" + tu1.id + "-" + it, "tweet text", System.currentTimeMillis(), "web")
          eventHandler.handleVertex(t)
          val edge = Edge(tu1.idNode.asInstanceOf[VertexId], t.idNode.asInstanceOf[VertexId], (ListBuffer("publishes"), 0L))
          eventHandler.handleEdge(edge)
          count += 1

          val numHashtagsThisTweet = rand.nextInt(avgNumHashtagsPerTweet * 2)
          val i = 0
          for (i <- 1 to numHashtagsThisTweet) {
            val htn = rand.nextInt(hashtags.size)
            val ht = hashtags(htn)
            val edge = Edge(t.idNode.asInstanceOf[VertexId], ht.idNode.asInstanceOf[VertexId], (ListBuffer("contains"), 0L))
            eventHandler.handleEdge(edge)
          }
        }
        val numFollowersPerFollower = rand.nextInt(avgNumFollowersPerUser * 2)

        for (it2 <- 1 to numFollowers) {
          val tu2 = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + count, "twitterUser" + count, "malaga", "false", "", "", "user" + count + "description", System.currentTimeMillis())
          eventHandler.handleVertex(tu2)
          val edge = Edge(tu2.idNode.asInstanceOf[VertexId], tu1.idNode.asInstanceOf[VertexId], (ListBuffer("follows"), 0L)) //tu1 follows tu
          eventHandler.handleEdge(edge)
          count += 1
        }
      }
      var u = 0
      for (u <- 1 to numFlickrUsers) {
        val fu = new FlickrUser(count, System.currentTimeMillis() "flickr user " + count, "flickr user " + count, "malaga");
        flickrUsers += fu
        nodesArray = nodesArray :+ (nextVertexNum, fu)
        count += 1
      }
      val fu = new FlickrUser(count, System.currentTimeMillis(), "flickrUser" + count, "flickrUser" + count, "malaga")
      eventHandler.handleVertex(fu)
      count += 1
      
      val numPhotos = rand.nextInt(avgNumPhotoPerUser * 2)
      val itPhoto = 0
      for (itPhoto <- 1 to numPhotos) {
        val p = new Photo(count, System.currentTimeMillis(), "photo title", "photo-"+fu.id+"-"+count, "photo description", System.currentTimeMillis(), System.currentTimeMillis(), "cannon")
        eventHandler.handleVertex(p)
        val edge = Edge(fu.idNode.asInstanceOf[VertexId], p.idNode.asInstanceOf[VertexId], (ListBuffer("owns"), 0L))
        eventHandler.handleEdge(edge)
        count += 1

        val numHashtagsThisPhoto = rand.nextInt(avgNumHashtagsPerTweet * 2)
        val itHtPhoto = 0
        for (itHtPhoto <- 1 to numHashtagsThisPhoto) {
          val htn = rand.nextInt(hashtags.size)
          val ht = hashtags(htn);
          val edge = Edge(p.idNode.asInstanceOf[VertexId], ht.idNode.asInstanceOf[VertexId], (ListBuffer("tags"), 0L))
          eventHandler.handleEdge(edge)
        }
        
        
        
      }
      
      
      
      
      

    }
                   
  }
   
    def getStartingMessage(): String = {
        val sb = new StringBuilder();
        sb.append("\n\n************************************************************");
        sb.append("\n* STARTING - ");
        sb.append("\n* PLEASE WAIT -");
        sb.append("\n* A WHILE TO SEE WARNING AND CRITICAL EVENTS!");
        sb.append("\n************************************************************\n");
        return sb.toString();
    }
}