package com.cor.graphx.handler

import org.apache.spark.SparkContext
import org.apache.spark.graphx.Edge
import org.apache.spark.graphx.Graph
import org.apache.spark.graphx.VertexId
import scala.collection.mutable.ListBuffer
import com.cor.graphx.util.VertexProperty
import scala.collection.mutable.ArrayBuffer

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.apache.spark.rdd.RDD
import org.apache.spark.graphx.EdgeTriplet
import com.cor.graphx.event.Photo
import com.cor.graphx.event.Hashtag
import com.cor.graphx.event.Tweet
import com.cor.graphx.event.TwitterUser
import com.cor.graphx.event.FlickrUser
import org.apache.spark.graphx.EdgeDirection

class FlickrTwitterEventHandler(sc: SparkContext) {

  var graph: Graph[(VertexProperty), (ListBuffer[String], Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var vertices: RDD[(VertexProperty)] = sc.emptyRDD
  var edges: RDD[Edge[(ListBuffer[String], Long)]] = sc.emptyRDD
  var triplets: RDD[EdgeTriplet[VertexProperty, (ListBuffer[String], Long)]] = sc.emptyRDD

  //Queries

  var hotTopicRelation = ListBuffer[Edge[(String, String, Long)]]()
  var nodesArrayHotTopic = ArrayBuffer[(VertexId, VertexProperty)]()

  var popularTPRelation = ListBuffer[Edge[(String, String, Long)]]()
  var nodesArrayPopularTP = ArrayBuffer[(VertexId, VertexProperty)]()

  var popularFPRelation = ListBuffer[Edge[(String, String, Long)]]()
  var nodesArrayPopularFP = ArrayBuffer[(VertexId, VertexProperty)]()

  //Graph HotTopic with Hashtag properties and event date
  var graphHotTopic: Graph[(VertexProperty, Long), (ListBuffer[String], Long)] = null
  
  var verticesHotTopic : RDD[(VertexId,(VertexProperty, Long))] = sc.emptyRDD
  //Graph PopularFlickrPhoto with Photo properties and event date
  var graphPopularFP: Graph[(VertexProperty, Long), (ListBuffer[String], Long)] = null
  //Graph PopularTwitterPhoto with Photo, Hashtag and edges with event date in third attribute
  var graphPopularTP: Graph[VertexProperty, (ListBuffer[String], Long)] = null
  var graphNiceTP: Graph[VertexProperty, (ListBuffer[String], Long)] = null

  var graphMisunderstood: Graph[VertexProperty, (ListBuffer[String], Long)] = null

  var graphInfluencerTweeted: Graph[VertexProperty, (ListBuffer[String], Long)] = null

  
  
  /**
   * Handle the incoming event.
   */
  def handleVertex(event: VertexProperty) = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    Thread.sleep(100)
    vertices = vertices ++ sc.parallelize(Seq(event))

    deleteGraph

  }

  /**
   * Handle the incoming edge.
   */
  def handleEdge(edge: Edge[(ListBuffer[String], Long)]) = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    Thread.sleep(100)
    
    edges = edges ++ sc.parallelize(Seq(edge))

    deleteGraph

  }

  def deleteGraph = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)

    graph = Graph(vertices.map(r => (r.idVertex, r)), edges)

    //Filter
    graph = graph.subgraph(vpred = (id, attr) => !attr.isInstanceOf[Tweet] || (attr.isInstanceOf[Tweet] && (System.currentTimeMillis() - attr.currentTimeStamp) < 3600000), epred = e => (e.dstAttr != null) && (e.srcAttr != null) && (!e.dstAttr.isInstanceOf[Tweet] || (e.dstAttr.isInstanceOf[Tweet] && (System.currentTimeMillis() - e.dstAttr.currentTimeStamp) < 3600000)) && (!e.srcAttr.isInstanceOf[Tweet] || (e.srcAttr.isInstanceOf[Tweet] && (System.currentTimeMillis() - e.srcAttr.currentTimeStamp) < 3600000)))

    vertices = graph.vertices.map { case (id, attr) => attr }
verticesHotTopic.foreach(println(_))
    edges = graph.edges
  }

  //Query 1 ---------------- HOTTOPIC --------------------------------------------

  def hotTopic {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    if (graph != null) {

      try {
        val start = System.currentTimeMillis()

        val hashtagTweetPhotoFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Hashtag] || (attr.isInstanceOf[Tweet] && (System.currentTimeMillis() - attr.asInstanceOf[Tweet].date) < 360000000) || (attr.isInstanceOf[Photo] && (System.currentTimeMillis() - attr.asInstanceOf[Photo].dateLastUpdate) < 360000000)), epred = t => t.attr.toString.contains("contains") || t.attr.toString.contains("tags")) //TODO 3600000 timestamp

        val hashtagTweetPhotoFilterInDegrees = hashtagTweetPhotoFilter.outerJoinVertices(hashtagTweetPhotoFilter.inDegrees) { (id, _, counter) =>
          counter match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          }
        }

        //if (hashtagTweetPhotoFilterInDegrees.triplets.count != 0) {
        
        
        
        //Result HotTopic graph with Hashtags
        val graphHotTopicAux = graph.mask(hashtagTweetPhotoFilterInDegrees.subgraph(vpred = (id, attr) => attr >= 100)).mapVertices((id, attr) => (attr, System.currentTimeMillis()))
        
        verticesHotTopic =  graphHotTopicAux.vertices.++(verticesHotTopic)

        val end = System.currentTimeMillis()

        logger.info("task in " + (end - start))
        
        //verticesHotTopic.foreach(println(_))

      } catch {
        case e: IllegalArgumentException => logger.info(e.toString)

      }
    }
  }
  //----------------------------------------

  //Query 2 ---------------- POPULARTWITTERPHOTO --------------------------------------------
  def popularTwitterPhoto {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    try {
      val start = System.currentTimeMillis()
      val hashtagTweetPhotoUserFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Hashtag] || (attr.isInstanceOf[Tweet] && (System.currentTimeMillis() - attr.asInstanceOf[Tweet].date) < 360000000) || attr.isInstanceOf[Photo] || attr.isInstanceOf[TwitterUser]), epred = t => t.attr.toString().contains("contains") || t.toString().contains("tags") || t.attr.toString().contains("likes")) // TODO 3600000 timestamp

      //Filter relation tags
      val photoHashtagFilter = hashtagTweetPhotoUserFilter.subgraph(vpred = (id, attr) => attr.isInstanceOf[Photo] || attr.isInstanceOf[Hashtag], epred = t => t.attr._1(0) == "tags")

      //Filter to get likes between TwitterUsers and Tweets
      val likesFilter = hashtagTweetPhotoUserFilter.subgraph(vpred = (id, attr) => attr.isInstanceOf[Tweet] || attr.isInstanceOf[TwitterUser], epred = t => t.attr._1(0) == "likes" && (System.currentTimeMillis() - t.attr._2) < 360000000) // TODO 3600000 timestamp

      //Join the number of likes per tweet
      val queryLikes = hashtagTweetPhotoUserFilter.outerJoinVertices(likesFilter.inDegrees) { (id, oldAttr, counter) =>
        (oldAttr,
          counter match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
      }

      // Filter to get what Tweet (with more than 30 likes) contains what hashtag
      val containsFilter = queryLikes.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Tweet] && attr._2 > 30) || attr._1.isInstanceOf[Hashtag], epred = t => t.attr._1(0) == "contains")

      //Join the number of Tweets with more than 30 likes that use each hashtag
      val queryContains = hashtagTweetPhotoUserFilter.outerJoinVertices(containsFilter.inDegrees) { (id, oldAttr, counterLikes) =>
        (oldAttr,
          counterLikes match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
      }

      //Get a graph with photos that contains a hashtag that has been used by a tweet with more than 30 likes
      val tagsFilter = queryContains.subgraph(vpred = (id, attr) => attr._1.isInstanceOf[Photo] || (attr._1.isInstanceOf[Hashtag] && attr._2 > 0), epred = t => t.attr._1(0) == "tags")

      val queryTags = hashtagTweetPhotoUserFilter.outerJoinVertices(tagsFilter.degrees) { (id, oldAttr, counterLikes) =>
        (oldAttr,
          counterLikes match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
      }

      val photosFilter = queryTags.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Hashtag] && attr._2 > 0) || (attr._1.isInstanceOf[Photo] && attr._2 > 0), epred = t => t.attr._1(0) == "tags")

      //        graphPopularTP = graph.mask(photosFilter).mapEdges(e => (ListBuffer(e.attr._1(0), e.attr._1(1)), System.currentTimeMillis()))

      //Result HotTopic graph with Hashtags
      val graphPopularTPAux = graph.mask(photosFilter).mapEdges(e => (ListBuffer(e.attr._1(0), e.attr._1(1)), System.currentTimeMillis()))
      if (graphPopularTP != null) {
        graphPopularTP = Graph(graphPopularTP.vertices.union(graphPopularTPAux.vertices), graphPopularTP.edges.union(graphPopularTPAux.edges))
      } else {
        graphPopularTP = graphPopularTPAux
      }

      val end = System.currentTimeMillis()

      logger.info("task ptf in " + (end - start))
      //      if (graphPopularTP != null && !graphPopularTP.vertices.isEmpty()) {
      //        logger.info(graphPopularTP.vertices.count + "results")
      //      }

    } catch {
      case e: IllegalArgumentException => logger.info(e.toString)

    }
  }
  //----------------------------------------

  //Query 3 ---------------- POPULARFLICKRPHOTO --------------------------------------------
  def popularFlickrPhoto {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    try {

      val start = System.currentTimeMillis()
      val photoFlickuserFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Photo] || attr.isInstanceOf[FlickrUser]), epred = t => t.attr._1(0) == "favorites" || (t.attr._1(0) == "follows" && t.srcAttr.isInstanceOf[FlickrUser]))

      val followsFilter = photoFlickuserFilter.subgraph(vpred = (id, attr) => attr.isInstanceOf[FlickrUser], epred = t => t.attr._1(0) == "follows")

      val queryFollows = photoFlickuserFilter.outerJoinVertices(followsFilter.inDegrees) { (id, oldAttr, counterFollows) =>
        (oldAttr,
          counterFollows match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
      }

      val favoritesFilter = queryFollows.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Photo] || (attr._1.isInstanceOf[FlickrUser] && attr._2 > 50)), epred = t => t.attr._1(0) == "favorites")

      val queryFavorites = photoFlickuserFilter.outerJoinVertices(favoritesFilter.inDegrees) { (id, oldAttr, counterFollows) =>
        (oldAttr,
          counterFollows match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
      }

      val query3Filter = queryFavorites.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Photo] && attr._2 > 50))

      val graphPopularFPAux = graph.mask(query3Filter).mapVertices((id, attr) => (attr, System.currentTimeMillis()))
      if (graphPopularFP != null) {
        graphPopularFP = Graph(graphPopularFP.vertices.union(graphPopularFPAux.vertices), graphPopularFP.edges.union(graphPopularFPAux.edges))
      } else {
        graphPopularFP = graphPopularFPAux
      }
      val end = System.currentTimeMillis()

      //logger.info("task ptf in " + (end - start))
      logger.info(graphPopularTP.triplets + "results")
      logger.info(graphPopularTP.numEdges + "results")
      //      if (graphPopularFP != null && !graphPopularFP.triplets.isEmpty()) {
      //        logger.info(graphPopularTP.numEdges + "results")
      //      }
    } catch {
      case e: IllegalArgumentException => logger.info(e.toString)
      case e1: NullPointerException    =>
    }

  }

  // Query 4 ---------------- NICETWITTERPHOTO ---------------------------
  def niceTwitterPhoto {

    //Subgraph that contains Hashtags, Tweets from the last hour, TwitterUsers  and relations follows (Between two TwitterUsers), contains (Between Tweet and Hashtag), publishes (between TwitterUser and Tweet)
    val userFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Hashtag] || (attr.isInstanceOf[Tweet] && (System.currentTimeMillis() - attr.asInstanceOf[Tweet].date) < 360000000) || attr.isInstanceOf[TwitterUser] || attr.isInstanceOf[Photo]), epred = t => t.toString().contains("contains") || t.toString().contains("publishes") || t.toString().contains("follows") || t.toString().contains("tags")) // TODO 3600000 timestamp

    // ------ INIT H-INDEX ------
    //Filter userFilter to get who TwitterUsers follows each TwitterUser
    val userUserFilter = userFilter.subgraph(vpred = (id, attr) => (attr.isInstanceOf[TwitterUser]), epred = t => t.toString().contains("follows"))

    //Calculate the number of followers per user
    val followersPerUser = userUserFilter.outerJoinVertices(userUserFilter.inDegrees) { (id, oldAttr, counterLikes) =>
      (
        counterLikes match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })
    }
    //Add a list with the number of followers per user of the followers
    val followersPerFollower = followersPerUser.aggregateMessages[List[Long]](
      triplet => {
        // Send message to destination vertex containing a list of followers per follower
        triplet.sendToDst(List(triplet.srcAttr))
      },
      // Add followers
      (x, y) => (x ++ y) // Reduce Function
    )

    //Users with h Index
    val userHIndex = userFilter.outerJoinVertices(followersPerFollower.mapValues(followers => hIndex(followers))) { (id, oldAttr, counterLikes) =>
      (oldAttr,
        counterLikes match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })
    }
    // ----- FIN H-INDEX-----

    val filterRelevantUsers = userHIndex.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Hashtag] || attr._1.isInstanceOf[Tweet] || (attr._1.isInstanceOf[TwitterUser] && attr._2 > 50) || attr._1.isInstanceOf[Photo]), epred = t => t.toString().contains("contains") || t.toString().contains("publishes") || t.toString().contains("tags")) //

    //This graph considers only TwitterUsers with an h-index higger than 50
    val graphRelevantUsers = userFilter.mask(filterRelevantUsers)

    //Filter triplets with Photo-Hashtag relation
    val photoHashtagRelation = userFilter.subgraph(vpred = (id, attr) => attr.isInstanceOf[Hashtag] || attr.isInstanceOf[Photo], epred = t => t.toString().contains("tags"))

    val userTweetFilter = userFilter.aggregateMessages[VertexId](
      triplet => { // Map Function
        if (triplet.srcAttr.isInstanceOf[TwitterUser] && triplet.dstAttr.isInstanceOf[Tweet]) {
          // Send message to destination vertex containing idTwitterUser
          triplet.sendToDst(triplet.srcId)

        }
      },
      // Add user Twitter id
      (a, b) => (b) // Reduce Function
    )

    // Join with first filter userFilter
    val addUsertoTweet = userFilter.outerJoinVertices(userTweetFilter) { (vid, oldAttr, newOpt) =>
      (oldAttr,
        newOpt match {
          case Some(outDeg) => outDeg
          case None         => None // No outDegree means zero outDegree
        })
    }
    // Get who TwitterUser has used what Hashtag
    val groupHashtagbyUser = addUsertoTweet.triplets.filter { t => t.dstAttr._1.isInstanceOf[Hashtag] && t.srcAttr._1.isInstanceOf[Tweet] }.groupBy(f => (f.srcAttr._2.asInstanceOf[VertexId], f.dstId.asInstanceOf[VertexId]))

    // Get who TwitterUser has used what Hashtag and how many times
    val numberHashtagByUser: RDD[((VertexId, VertexId), (ListBuffer[(String)], Long))] = groupHashtagbyUser.map {
      t => (t._1, (ListBuffer("hashtagUser", t._2.size.toString), 0))
    }
    // Get a graph with relations between TwitterUser and hashtag, and each TwitterUser has an h-index
    val edgesHashtagByUser: RDD[Edge[(ListBuffer[(String)], Long)]] = numberHashtagByUser.map { t => Edge(t._1._1, t._1._2, t._2) }
    val graphHashtagUsersT = userHIndex.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Hashtag] || attr._1.isInstanceOf[TwitterUser]), epred = e => e.dstAttr._1.isInstanceOf[Hashtag] && e.srcAttr._1.isInstanceOf[TwitterUser])
    val graphHashtagUsersTwitter = Graph(graphHashtagUsersT.vertices, graphHashtagUsersT.edges.union(edgesHashtagByUser))

    //Filter graph to get TwitterUsers with an h-index higger than 15 that are relationated with a hashtag at least three times
    val graphRelevantUserHashtag = graphHashtagUsersTwitter.subgraph(epred = e => e.dstAttr._1.isInstanceOf[Hashtag] && e.srcAttr._1.isInstanceOf[TwitterUser] && e.srcAttr._2 > 50 && e.attr._2.toLong > 2)

    val RelevantPhotoHashtag = photoHashtagRelation.outerJoinVertices(graphRelevantUserHashtag.inDegrees) { (id, oldAttr, counterDegrees) =>
      (oldAttr,
        counterDegrees match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })

    }
    val graphQuery4 = RelevantPhotoHashtag.subgraph(vpred = (id, attr) => (attr._1.isInstanceOf[Hashtag] && attr._2 != 0) || attr._1.isInstanceOf[Photo], epred = e => e.attr._1(0) == "tags" && e.srcAttr._1.isInstanceOf[Photo] && e.dstAttr._1.isInstanceOf[Hashtag] && e.dstAttr._2 != 0)

    val graphQuery4Degrees = graphQuery4.outerJoinVertices(graphQuery4.degrees) { (id, oldAttr, counterDegrees) =>
      (oldAttr,
        counterDegrees match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })

    }

    val maskQuery4 = graphQuery4Degrees.subgraph(vpred = (id, attr) => attr._2 != 0, epred = e => e.attr._1(0) == "tags")
    val graphNiceTPAux = graph.mask(maskQuery4).mapEdges(e => (e.attr._1, System.currentTimeMillis()))

    if (graphNiceTP != null) {
      graphNiceTP = Graph(graphNiceTP.vertices.union(graphNiceTPAux.vertices), graphNiceTP.edges.union(graphNiceTPAux.edges))
    } else {
      graphNiceTP = graphNiceTPAux
    }

  }

  // Query 5 ---------------- MISUNDERSTOOD ---------------------------
  def misunderstood {
    if (graphNiceTP != null) {
      //Subgraph that contains FlickrUsers, Photos  and relations follows (Between two FlickrUsers) and favorites (Between FlickrUser and Photo), publishes (between TwitterUser and Tweet)
      val flickrUserPhotoFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Photo] || attr.isInstanceOf[FlickrUser]), epred = t => t.toString().contains("follows") || t.toString().contains("favorites"))

      //Join outDegrees from graphNiceTP to flickrUserPhotoFilter
      val graphNiceTPOutDegree = flickrUserPhotoFilter.outerJoinVertices(graphNiceTP.outDegrees) { (id, oldAttr, counterDegrees) =>
        (oldAttr,
          counterDegrees match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })

      }

      //Select Photos from graphNiceTP and join with flickrUserPhotoFilter
      val graphNiceTPPhotos = graphNiceTPOutDegree.subgraph(vpred = (id, attr) => ((attr._1.isInstanceOf[Photo] && attr._2 > 0) || attr._1.isInstanceOf[FlickrUser]), epred = t => t.toString().contains("follows") || t.toString().contains("favorites"))

      val graphFlickrUserPhotoFilter = flickrUserPhotoFilter.mask(graphNiceTPPhotos)

      //add neighbors for each vertex
      val graphWithNeighbords = graphFlickrUserPhotoFilter.outerJoinVertices(graphFlickrUserPhotoFilter.ops.collectNeighborIds(EdgeDirection.In)) {
        (id, oldAttr, neighbors) =>
          (oldAttr,
            neighbors match {
              case Some(counter) => counter
              case None          => Array() // No inDegree means zero inDegree
            })
      }
      //Select relation favorites
      val photoFlickrUserWithNeighbords = graphWithNeighbords.subgraph(epred = e => e.attr._1 == "favorites")
      val photoFlickrUserWithNeighbordsFilterEdges = photoFlickrUserWithNeighbords.subgraph(epred = e => ((e.srcAttr._2).intersect(e.dstAttr._2)).length == 0)
      val photoFlickrUserWithNeighbordsFilterEdgesDegrees = photoFlickrUserWithNeighbordsFilterEdges.outerJoinVertices(photoFlickrUserWithNeighbordsFilterEdges.degrees) {
        (id, oldAttr, counterDegrees) =>
          (oldAttr,
            counterDegrees match {
              case Some(counter) => counter
              case None          => 0 // No inDegree means zero inDegree
            })
      }
      val graphQuery5 = photoFlickrUserWithNeighbordsFilterEdgesDegrees.subgraph(vpred = (id, attr) => attr._2 > 0)
      val graphMisunderstoodAux = graph.mask(graphQuery5).mapEdges(e => (e.attr._1, System.currentTimeMillis()))

      if (graphMisunderstood != null) {
        graphMisunderstood = Graph(graphMisunderstood.vertices.union(graphMisunderstoodAux.vertices), graphMisunderstood.edges.union(graphMisunderstoodAux.edges))
      } else {
        graphMisunderstood = graphMisunderstoodAux
      }
    }
  }

  // Query 6 ---------------- NICEFLICKRPHOTO ---------------------------
  def niceFlickrPhoto {

  }

  // Query 7 ---------------- INFLUENCERTWEETED ---------------------------
  def influencerTweeted {
    //Array that contains the last 10000 Tweets
    val recentTweets = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[Tweet])).vertices.sortBy(_._2.asInstanceOf[Tweet].date, ascending = false).map { case (id, attr) => id }.take(10000) //TODO 10000 en vez de 10

    // ------ INIT H-INDEX ------
    //Filter userFilter to get who TwitterUsers follows each TwitterUser
    val userUserFilter = graph.subgraph(vpred = (id, attr) => (attr.isInstanceOf[TwitterUser]), epred = t => t.toString().contains("follows"))

    //Calculate the number of followers per user
    val followersPerUser = userUserFilter.outerJoinVertices(userUserFilter.inDegrees) { (id, oldAttr, counterLikes) =>
      (
        counterLikes match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })
    }
    //Add a list with the number of followers per user of the followers
    val followersPerFollower = followersPerUser.aggregateMessages[List[Long]](
      triplet => {
        // Send message to destination vertex containing a list of followers per follower
        triplet.sendToDst(List(triplet.srcAttr))
      },
      // Add followers
      (x, y) => (x ++ y) // Reduce Function
    )

    //Users with h Index
    val userHIndex = graph.outerJoinVertices(followersPerFollower.mapValues(followers => hIndex(followers))) { (id, oldAttr, counterLikes) =>
      (oldAttr,
        counterLikes match {
          case Some(counter) => counter
          case None          => 0 // No inDegree means zero inDegree
        })
    }
    // ----- FIN H-INDEX-----
    val userHIndexFollowers = userHIndex.outerJoinVertices(userUserFilter.inDegrees) {
      (id, oldAttr, newAttr) =>
        (oldAttr,
          newAttr match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
    }
    val recentTweetsUsers = userHIndexFollowers.subgraph(vpred = (id, attr) => (attr._1._1.isInstanceOf[Tweet] && recentTweets.contains(id)) || (attr._1._1.isInstanceOf[TwitterUser] && attr._1._2 > 300 && attr._2 > 50000), epred = e => e.attr._1 == "publishes") //TODO 300 en vez de 30 y 50000 en vez de 70
    val recentTweetsUsersDegrees = recentTweetsUsers.outerJoinVertices(recentTweetsUsers.degrees) {
      (id, oldAttr, newAttr) =>
        (oldAttr._1._1,
          newAttr match {
            case Some(counter) => counter
            case None          => 0 // No inDegree means zero inDegree
          })
    }
    val graphInfluencerTweetedAux = graph.mask(recentTweetsUsersDegrees.subgraph(vpred = (id, attr) => attr._2 != 0))

    if (graphInfluencerTweeted != null) {
      graphInfluencerTweeted = Graph(graphInfluencerTweeted.vertices.union(graphInfluencerTweetedAux.vertices), graphInfluencerTweeted.edges.union(graphInfluencerTweetedAux.edges))
    } else {
      graphInfluencerTweeted = graphInfluencerTweetedAux
    }

  }

  //H INDEX FUNCTION
  def hIndex(citations: List[Long]): Long = {
    val citationsSorted: List[Long] = citations.sorted
    var result = 0L
    var i = 0
    for (i <- 0 to citationsSorted.length - 1) {
      val smaller = Math.min(citationsSorted(i), citationsSorted.length - i)
      result = Math.max(result, smaller)
    }

    return result
  }

  
  //Method to pool graph 
  def poolGraph: Long = {
    val logger: org.slf4j.Logger = org.slf4j.LoggerFactory.getLogger(this.getClass)

    val numInactiveTwitterUsers = 100//1000
    val numInfluencerTwitterUsers = 0
    val numActiveTwitterUsers = 10//100
    val numFlickrUsers = 100//1000
    val numHashtags = 10

    // Edges
    val avgNumFollowersPerUser = 60
    val avgNumFollowersPerInfluencer = 40000
    val avgNumFollowersPerFlickrUser = 50
    val avgNumPhotoPerUser = 10
    val avgNumTweetPerUser = 10
    val avgNumTweetPerInfluencer = 100
    val avgNumHashtagsPerTweet = 2
    val avgNumLikesPerTweet = 20
    val avgNumMentionsInTweet = 1
    val avgNumFavoritesPerPhoto = 50
    val avgNumCommentsPerPhoto = 2
    // Nodes
    var nodesArray = List[(VertexProperty)]()
    var inactiveTwitterUsers = List[TwitterUser]()
    var influencerTwitterUsers = List[TwitterUser]()
    var activeTwitterUsers = List[TwitterUser]()
    var flickrUsers = List[FlickrUser]()
    var photos = List[Photo]()
    var tweets = List[Tweet]()
    var hashtags = List[Hashtag]()

    //Edges

    var flickrUserUserRelation = List[Edge[(ListBuffer[(String)], Long)]]()
    var twitterUserUserRelation = List[Edge[(ListBuffer[(String)], Long)]]()
    var twitterUserTweetRelation = List[Edge[(ListBuffer[(String)], Long)]]()
    var flickrUserPhotoRelation = List[Edge[(ListBuffer[(String)], Long)]]()
    var tweetHashtagEdge = List[Edge[(ListBuffer[(String)], Long)]]()
    var photoHashtagEdge = List[Edge[(ListBuffer[(String)], Long)]]()
    var count = 0L

    //Node creation
    var i = 0
    for (i <- 1 to numInactiveTwitterUsers) {
      val user = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + i, "twitterUser" + i, "malaga", "false", "", "", "user" + i + "description", System.currentTimeMillis())
      inactiveTwitterUsers = inactiveTwitterUsers :+ user
      nodesArray = nodesArray :+ user
      count += 1

    }

    var x = numInactiveTwitterUsers
    for (x <- numInactiveTwitterUsers + 1 to (numInactiveTwitterUsers + numActiveTwitterUsers)) {
      val user = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + x, "twitterUser" + x, "malaga", "false", "", "", "user" + x + "description", System.currentTimeMillis())
      activeTwitterUsers = activeTwitterUsers :+ user
      nodesArray = nodesArray :+ user
      count += 1
    }

    var y = (numInactiveTwitterUsers + numActiveTwitterUsers)
    for (x <- (numInactiveTwitterUsers + numActiveTwitterUsers + 1) to (numInactiveTwitterUsers + numActiveTwitterUsers + numInfluencerTwitterUsers)) {
      val user = new TwitterUser(count, System.currentTimeMillis(), "twitterUser" + x, "twitterUser" + x, "malaga", "false", "", "", "user" + x + "description", System.currentTimeMillis())
      influencerTwitterUsers = influencerTwitterUsers :+ user
      nodesArray = nodesArray :+ user
      count += 1
    }

    var u = 0
    for (u <- 1 to numFlickrUsers) {
      val fu = new FlickrUser(count, System.currentTimeMillis(), "flickr user " + u, "flickr user " + u, "malaga");
      flickrUsers = flickrUsers :+ fu
      nodesArray = nodesArray :+ fu
      count += 1
    }

    var p = 0
    for (p <- 1 to numHashtags) {
      val ht = new Hashtag(count, System.currentTimeMillis(), "hashtag" + p)
      hashtags = hashtags :+ ht
      nodesArray = nodesArray :+ ht
      count += 1
    }

    //Edge creation
    val allUsers = inactiveTwitterUsers ++ activeTwitterUsers
    for (tu <- allUsers) {
      val rand = scala.util.Random
      val numFollowers = rand.nextInt(avgNumFollowersPerUser * 2)
      var it = 0
      for (it <- 1 to numFollowers) {
        val n = rand.nextInt(allUsers.size) //get random user
        val tu1 = allUsers(n)
        val edge = Edge(tu1.idNode.asInstanceOf[VertexId], tu.idNode.asInstanceOf[VertexId], (ListBuffer("follows"), 0L)) //tu1 follows tu
        twitterUserUserRelation = twitterUserUserRelation :+ edge
      }
    }
    val allUsersWithInfluencer = allUsers ++ influencerTwitterUsers
    for (tu <- influencerTwitterUsers) {
      val rand = scala.util.Random
      val numFollowers = rand.nextInt(avgNumFollowersPerInfluencer * 2)
      var it = 0
      for (it <- 1 to numFollowers) {
        val n = rand.nextInt(allUsersWithInfluencer.size) //get random user
        val tu1 = allUsersWithInfluencer(n)
        val edge = Edge(tu1.idNode.asInstanceOf[VertexId], tu.idNode.asInstanceOf[VertexId], (ListBuffer("follows"), 0L)) //tu1 follows tu
        twitterUserUserRelation = twitterUserUserRelation :+ edge
      }
    }

    for (fu <- flickrUsers) {
      val rand = scala.util.Random
      val numFollowers = rand.nextInt(avgNumFollowersPerFlickrUser * 2)
      val it = 0
      for (it <- 1 to numFollowers) {
        val n = rand.nextInt(flickrUsers.size) //get random user
        val fu1 = flickrUsers(n)
        val edge = Edge(fu1.idNode.asInstanceOf[VertexId], fu.idNode.asInstanceOf[VertexId], (ListBuffer("follows"), 0L)) //tu1 follows tu
        flickrUserUserRelation = flickrUserUserRelation :+ edge
      }
    }

    for (tu <- activeTwitterUsers) {
      val rand = scala.util.Random
      val numTweets = rand.nextInt(avgNumTweetPerUser * 2)
      val it = 0
      for (it <- 1 to numTweets) {
        val t = new Tweet(count, System.currentTimeMillis(), "tweet-" + tu.id + "-" + i, "tweet text", System.currentTimeMillis(), "web")
        tweets = tweets :+ t
        val edge = Edge(tu.idNode.asInstanceOf[VertexId], t.idNode.asInstanceOf[VertexId], (ListBuffer("publishes"), 0L))
        twitterUserTweetRelation = twitterUserTweetRelation :+ edge
        nodesArray = nodesArray :+ t
        count += 1
      }
    }

    for (tu <- influencerTwitterUsers) {
      val rand = scala.util.Random
      val numTweets = rand.nextInt(avgNumTweetPerInfluencer * 2)
      val it = 0
      for (it <- 1 to numTweets) {
        val t = new Tweet(count, System.currentTimeMillis(), "tweet-" + tu.id + "-" + i, "tweet text", System.currentTimeMillis(), "web")
        tweets = tweets :+ t
        val edge = Edge(tu.idNode.asInstanceOf[VertexId], t.idNode.asInstanceOf[VertexId], (ListBuffer("publishes"), 0L))
        twitterUserTweetRelation = twitterUserTweetRelation :+ edge
        nodesArray = nodesArray :+ t
        count += 1
      }
    }

    for (fu <- flickrUsers) {
      val rand = scala.util.Random
      val numPhotos = rand.nextInt(avgNumPhotoPerUser * 2);
      val it = 0
      for (it <- 1 to numPhotos) {
        val p = new Photo(count, System.currentTimeMillis(), "photo title", "photo-" + fu.id + "-" + i, "photo description", System.currentTimeMillis(), System.currentTimeMillis(), "cannon");
        photos = photos :+ p
        val edge = Edge(fu.idNode.asInstanceOf[VertexId], p.idNode.asInstanceOf[VertexId], (ListBuffer("owns"), 0L))
        flickrUserPhotoRelation = flickrUserPhotoRelation :+ edge;
        nodesArray = nodesArray :+ p
        count += 1
      }
    }

    for (tweet <- tweets) {
      val rand = scala.util.Random
      val numHashtagsThisTweet = rand.nextInt(avgNumHashtagsPerTweet * 2)
      val i = 0
      for (i <- 1 to numHashtagsThisTweet) {
        val htn = rand.nextInt(hashtags.size)
        val ht = hashtags(htn)
        val edge = Edge(tweet.idNode.asInstanceOf[VertexId], ht.idNode.asInstanceOf[VertexId], (ListBuffer("contains"), 0L))
        tweetHashtagEdge = tweetHashtagEdge :+ edge
      }
    }

    for (photo <- photos) {
      val rand = scala.util.Random
      val numHashtagsThisPhoto = rand.nextInt(avgNumHashtagsPerTweet * 2)
      val it = 0
      for (it <- 1 to numHashtagsThisPhoto) {
        val htn = rand.nextInt(hashtags.size)
        val ht = hashtags(htn);
        val edge = Edge(photo.idNode.asInstanceOf[VertexId], ht.idNode.asInstanceOf[VertexId], (ListBuffer("tags"), 0L))
        photoHashtagEdge = photoHashtagEdge :+ edge
      }
    }
    logger.info("nodes done")
    // Likes, Favorites...
    var likes = List[Edge[(ListBuffer[(String)], Long)]]()
    var mentions = List[Edge[(ListBuffer[(String)], Long)]]()
    var favorites = List[Edge[(ListBuffer[(String)], Long)]]()
    var comments = List[Edge[(ListBuffer[(String)], Long)]]()

    for (tweet <- tweets) {
      val rand = scala.util.Random
      val numLikesThisTweet = rand.nextInt(avgNumLikesPerTweet * 2)
      val it = 0
      for (it <- 1 to numLikesThisTweet) {
        val index = rand.nextInt(allUsers.size)
        val tu = allUsers(index)
        val like = Edge(tu.idNode.asInstanceOf[VertexId], tweet.idNode.asInstanceOf[VertexId], (ListBuffer("likes"), System.currentTimeMillis()))
        likes = likes :+ like
      }
    }

    for (tweet <- tweets) {
      val rand = scala.util.Random
      val numMentionsThisTweet = rand.nextInt(avgNumMentionsInTweet * 2)
      val it = 0
      for (it <- 1 to numMentionsThisTweet) {
        val index = rand.nextInt(allUsers.size)
        val tu = allUsers(index)
        val mention = Edge(tweet.idNode.asInstanceOf[VertexId], tu.idNode.asInstanceOf[VertexId], (ListBuffer("mentions"), 0L))
        mentions = mentions :+ mention
      }
    }

    for (photo <- photos) {
      val rand = scala.util.Random
      val numLikesThisPhoto = rand.nextInt(avgNumFavoritesPerPhoto * 2)
      val it = 0
      for (it <- 1 to numLikesThisPhoto) {
        val index = rand.nextInt(flickrUsers.size)
        val fu = flickrUsers(index)
        val fav = Edge(fu.idNode.asInstanceOf[VertexId], photo.idNode.asInstanceOf[VertexId], (ListBuffer("favorites"), System.currentTimeMillis()))
        favorites = favorites :+ fav
      }
    }
    logger.info("fav done")
    for (photo <- photos) {
      val rand = scala.util.Random
      val numCommentsThisPhoto = rand.nextInt(avgNumCommentsPerPhoto * 2)
      val it = 0
      for (it <- 1 to numCommentsThisPhoto) {
        val index = rand.nextInt(flickrUsers.size)
        val fu = flickrUsers(index)
        val c = Edge(fu.idNode.asInstanceOf[VertexId], photo.idNode.asInstanceOf[VertexId], (ListBuffer("comments", "comment text"), System.currentTimeMillis()))
        comments = comments :+ c
      }
    }

    val nodes = inactiveTwitterUsers ++ activeTwitterUsers ++ influencerTwitterUsers ++ flickrUsers ++ tweets ++ hashtags ++ photos
    val edgesPool = twitterUserUserRelation ++ flickrUserUserRelation ++ twitterUserTweetRelation ++ flickrUserPhotoRelation ++ tweetHashtagEdge ++ photoHashtagEdge ++ likes ++ mentions ++ comments ++ favorites

    

    vertices = sc.parallelize(nodes)
    edges = sc.parallelize(edgesPool)
    
    graph = Graph(vertices.map(r => (r.idVertex, r)), edges)
    
   logger.info("Graph created")

    return count
  }

}