package com.cor.graphx.handler

import scala.collection.mutable.ListBuffer

import org.apache.spark.SparkContext
import org.apache.spark.graphx.Edge
import org.apache.spark.graphx.Graph
import org.apache.spark.graphx.VertexId
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import com.cor.graphx.event.BlowOutTireEvent
import com.cor.graphx.event.CrashEvent
import com.cor.graphx.event.DriverLeftSeatEvent
import com.cor.graphx.event.MotorbikeEvent
import com.cor.graphx.event.OccupantThrownAccidentEvent
import com.cor.graphx.util.VertexProperty
import com.cor.graphx.subscriber.DriverLeftSeatSubscriber
import com.cor.graphx.subscriber.CrashSubscriber
import com.cor.graphx.subscriber.BlowOutTireSubscriber

class MotorbikeEventHandler(sc: SparkContext) {

  var graph: Graph[(VertexProperty), (String, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var vertices = ListBuffer[(VertexProperty)]()
  var edges = ListBuffer[Edge[(String, String, Long)]]()

  var graphCrash: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)

  var graphBlowOutTire: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)

  var graphDriverLeftSeat: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)

  var graphOccupantThrownAccident: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)


  /**
   * Handle the incoming event.
   */
  def handleVertex(event: VertexProperty) = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    
    if(event != null){
      logger.info(event.toString());
      vertices = vertices :+ event
    }

    vertices = vertices.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) < 5000 }
    graph = Graph(sc.parallelize(vertices).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1)), sc.parallelize(edges))

  }
  
 

  /**
   * Handle the incoming edge.
   */
  def handleEdge(edge: Edge[(String, String, Long)]) = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)

    if(edge != null){
      logger.info(edge.toString())
      edges = edges :+ edge
    }
    
    vertices = vertices.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) < 5000 }
    graph = Graph(sc.parallelize(vertices).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1)), sc.parallelize(edges))
    
  }

  
  def initService(){
    val threadDriverLeftSeat = new Thread {
      override def run {
        while (true) {
          driverLeftSeat

        }
      }
    }
    
    threadDriverLeftSeat.start
    
  }

  // ----------------------- CRASH -------------------------
  def crash() {

    val c = new CrashSubscriber(sc, graph)

    c.crash()

  }

  // ----------------------- BLOWOUTTIRE -------------------------
  def blowOutTire() {
    
    val bot = new BlowOutTireSubscriber(sc, graph)

    bot.blowOutTire()
    
  }
  // ---------------- DRIVERLEFTSEAT ------------------

  def driverLeftSeat() {
    
    val dls = new DriverLeftSeatSubscriber(sc, graph)

    dls.driverLeftSeat()

  }

  // ---------------- OCCUPANTTHROWNACCIDENT ------------------

  def occupantThrownAccident() {
    val graphUnion = Graph(graphCrash.vertices.union(graphBlowOutTire.vertices.union(graphDriverLeftSeat.vertices)), graphCrash.edges.union(graphBlowOutTire.edges.union(graphDriverLeftSeat.edges)))
    val groupMotorbike = graphUnion.vertices.groupBy(attr => {
      if (attr._2.isInstanceOf[DriverLeftSeatEvent]) {
        attr._2.asInstanceOf[DriverLeftSeatEvent].motorbikeId
      } else if (attr._2.isInstanceOf[CrashEvent]) {
        attr._2.asInstanceOf[CrashEvent].motorbikeId
      } else if (attr._2.isInstanceOf[BlowOutTireEvent]) {
        attr._2.asInstanceOf[BlowOutTireEvent].motorbikeId
      }
    })

    val groupMotorbikeOrder = groupMotorbike.map(f => (f._1, f._2.toList.sortBy(f => f._2.asInstanceOf[VertexProperty].currentTimeStamp))).collect
    verticesOccupantThrownAccident = verticesOccupantThrownAccident ++ groupMotorbikeOrder.flatMap(f => isOccupantThrownAccident(f._2))
    val occupantThrownAccidentVertices = sc.parallelize(verticesOccupantThrownAccident).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1))
    verticesOccupantThrownAccident = verticesOccupantThrownAccident.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) <= 3000 } //TODO ventana
    graphOccupantThrownAccident = Graph(occupantThrownAccidentVertices, sc.parallelize(ListBuffer[Edge[(Integer, String, Long)]]()))
  }

  def isOccupantThrownAccident(list: List[(VertexId, VertexProperty)]): ListBuffer[(VertexProperty)] = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    var result = ListBuffer[(VertexProperty)]()
    for (a <- list; b <- list; c <- list) {
      if (a._2.isInstanceOf[BlowOutTireEvent]
        && b._2.isInstanceOf[CrashEvent]
        && c._2.isInstanceOf[DriverLeftSeatEvent]
        && a._2.asInstanceOf[VertexProperty].currentTimeStamp < b._2.asInstanceOf[VertexProperty].currentTimeStamp
        && b._2.asInstanceOf[VertexProperty].currentTimeStamp < c._2.asInstanceOf[VertexProperty].currentTimeStamp
        && (c._2.asInstanceOf[VertexProperty].currentTimeStamp - a._2.asInstanceOf[VertexProperty].currentTimeStamp) <= 3000
        && sc.parallelize(verticesOccupantThrownAccident).filter(attr => attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp1 == a._2.asInstanceOf[BlowOutTireEvent].timestamp && attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp2 == b._2.asInstanceOf[CrashEvent].timestamp && attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp3 == c._2.asInstanceOf[DriverLeftSeatEvent].timestamp).count == 0) {
        val occupantThrownAccidentEvent = new OccupantThrownAccidentEvent(System.currentTimeMillis(), c._2.asInstanceOf[DriverLeftSeatEvent].motorbikeId, c._2.asInstanceOf[DriverLeftSeatEvent].location, a._2.asInstanceOf[BlowOutTireEvent].timestamp, b._2.asInstanceOf[CrashEvent].timestamp, c._2.asInstanceOf[DriverLeftSeatEvent].timestamp)
        logger.info(occupantThrownAccidentEvent.toString)
        result += occupantThrownAccidentEvent

      }
    }

    return result
  }


}