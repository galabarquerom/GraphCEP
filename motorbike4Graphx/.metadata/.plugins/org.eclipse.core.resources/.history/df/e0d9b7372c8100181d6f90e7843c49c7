package com.cor.graphx.handler

import scala.collection.mutable.ListBuffer

import org.apache.spark.SparkContext
import org.apache.spark.graphx.Edge
import org.apache.spark.graphx.Graph
import org.apache.spark.graphx.VertexId
import org.slf4j.Logger
import org.slf4j.LoggerFactory

import com.cor.graphx.event.BlowOutTireEvent
import com.cor.graphx.event.CrashEvent
import com.cor.graphx.event.DriverLeftSeatEvent
import com.cor.graphx.event.MotorbikeEvent
import com.cor.graphx.event.OccupantThrownAccidentEvent
import com.cor.graphx.util.VertexProperty
import com.cor.graphx.subscriber.DriverLeftSeatSubscriber

class MotorbikeEventHandler(sc: SparkContext) {

  var graph: Graph[(VertexProperty), (String, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var vertices = ListBuffer[(VertexProperty)]()
  var edges = ListBuffer[Edge[(String, String, Long)]]()

  var graphCrash: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var verticesCrash = ListBuffer[(VertexProperty)]()

  var graphBlowOutTire: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var verticesBlowOutTire = ListBuffer[(VertexProperty)]()

  var graphDriverLeftSeat: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)

  var graphOccupantThrownAccident: Graph[(VertexProperty), (Integer, String, Long)] = Graph(sc.emptyRDD, sc.emptyRDD)
  var verticesOccupantThrownAccident = ListBuffer[(VertexProperty)]()


  /**
   * Handle the incoming event.
   */
  def handle(event: VertexProperty, edge: Edge[(String, String, Long)]) = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    
    if(event != null){
      logger.info(event.toString());
      vertices = vertices :+ event
    }
    
    if (edge != null) {
      edges = edges :+ edge
    }
    vertices = vertices.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) < 5000 }
    graph = Graph(sc.parallelize(vertices).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1)), sc.parallelize(edges))
    
  }
  
  def initService(){
    val threadDriverLeftSeat = new Thread {
      override def run {
        while (true) {
          driverLeftSeat

        }
      }
    }
    
    threadDriverLeftSeat.run()
    
  }

  // ----------------------- CRASH -------------------------
  def crash() {

    val filterSpeed = graph.subgraph(vpred = (id, attr) => attr.isInstanceOf[MotorbikeEvent] && (attr.asInstanceOf[MotorbikeEvent].speed >= 50 || attr.asInstanceOf[MotorbikeEvent].speed == 0) && (System.currentTimeMillis() - attr.currentTimeStamp < 3000))
    val groupMotorbike = filterSpeed.vertices.groupBy(attr => attr._2.asInstanceOf[MotorbikeEvent].motorbikeId)
    val groupMotorbikeOrder = groupMotorbike.map(f => (f._1, f._2.toList.sortBy(f => f._2.asInstanceOf[MotorbikeEvent].currentTimestamp))).collect
    verticesCrash = verticesCrash ++ groupMotorbikeOrder.flatMap(f => isCrash(f._2))
    val crashVertices = sc.parallelize(verticesCrash).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1))
    verticesCrash = verticesCrash.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) < 3000 }
    graphCrash = Graph(crashVertices, sc.parallelize(ListBuffer[Edge[(Integer, String, Long)]]()))

  }

  def isCrash(list: List[(VertexId, VertexProperty)]): ListBuffer[(VertexProperty)] = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    var result = ListBuffer[(VertexProperty)]()

    for (a <- list; b <- list) {
      if (a._2.asInstanceOf[MotorbikeEvent].speed >= 50
        && b._2.asInstanceOf[MotorbikeEvent].speed == 0
        && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp - a._2.asInstanceOf[MotorbikeEvent].currentTimestamp) <= 3000 && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp >= a._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
        && sc.parallelize(verticesCrash).filter(attr => attr.asInstanceOf[CrashEvent].currentTimestamp1 == a._2.asInstanceOf[MotorbikeEvent].currentTimestamp && attr.asInstanceOf[CrashEvent].currentTimestamp2 == b._2.asInstanceOf[MotorbikeEvent].currentTimestamp).count == 0) {
        val crashEvent = new CrashEvent(System.currentTimeMillis(), a._2.asInstanceOf[MotorbikeEvent].motorbikeId, b._2.asInstanceOf[MotorbikeEvent].location, a._2.asInstanceOf[MotorbikeEvent].speed, b._2.asInstanceOf[MotorbikeEvent].speed, a._2.asInstanceOf[MotorbikeEvent].currentTimestamp, b._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
        result += crashEvent
        logger.info(crashEvent.toString)
      }
    }

    return result
  }

  // ----------------------- BLOWOUTTIRE -------------------------
  def blowOutTire() {
    val filterPressure = graph.subgraph(vpred = (id, attr) => attr.isInstanceOf[MotorbikeEvent] && ((attr.asInstanceOf[MotorbikeEvent].tirePressure1 >= 2 || attr.asInstanceOf[MotorbikeEvent].tirePressure1 <= 1.2) || (attr.asInstanceOf[MotorbikeEvent].tirePressure2 >= 2 || attr.asInstanceOf[MotorbikeEvent].tirePressure2 <= 1.2)))
    val groupMotorbike = filterPressure.vertices.groupBy(attr => attr._2.asInstanceOf[MotorbikeEvent].motorbikeId)
    val groupMotorbikeOrder = groupMotorbike.map(f => (f._1, f._2.toList.sortBy(f => f._2.asInstanceOf[MotorbikeEvent].currentTimestamp))).collect
    verticesBlowOutTire = verticesBlowOutTire ++ groupMotorbikeOrder.flatMap(f => isBlowOutTire(f._2))
    val blowOutTireVertices = sc.parallelize(verticesBlowOutTire).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1))
    verticesBlowOutTire = verticesBlowOutTire.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) < 3000 }
    graphBlowOutTire = Graph(blowOutTireVertices, sc.parallelize(ListBuffer[Edge[(Integer, String, Long)]]()))

  }

  def isBlowOutTire(list: List[(VertexId, VertexProperty)]): ListBuffer[(VertexProperty)] = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    var result = ListBuffer[(VertexProperty)]()
    for (a <- list; b <- list) {
      if (a._2.asInstanceOf[MotorbikeEvent].tirePressure1 >= 2
        && b._2.asInstanceOf[MotorbikeEvent].tirePressure1 <= 1.2
        && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp - a._2.asInstanceOf[MotorbikeEvent].currentTimestamp) < 5000 && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp > a._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
        && sc.parallelize(verticesBlowOutTire).filter(attr => attr.asInstanceOf[BlowOutTireEvent].currentTimestamp1 == a._2.asInstanceOf[MotorbikeEvent].currentTimestamp && attr.asInstanceOf[BlowOutTireEvent].currentTimestamp2 == b._2.asInstanceOf[MotorbikeEvent].currentTimestamp).count == 0) {
        val blowOutTireEvent = new BlowOutTireEvent(System.currentTimeMillis(), a._2.asInstanceOf[MotorbikeEvent].motorbikeId, b._2.asInstanceOf[MotorbikeEvent].location, a._2.asInstanceOf[MotorbikeEvent].tirePressure1, a._2.asInstanceOf[MotorbikeEvent].tirePressure2, b._2.asInstanceOf[MotorbikeEvent].location, b._2.asInstanceOf[MotorbikeEvent].tirePressure1, b._2.asInstanceOf[MotorbikeEvent].tirePressure2, a._2.asInstanceOf[MotorbikeEvent].currentTimestamp, b._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
        logger.info(blowOutTireEvent.toString)
        result += blowOutTireEvent
      } else {

        if (a._2.asInstanceOf[MotorbikeEvent].tirePressure2 >= 2
          && b._2.asInstanceOf[MotorbikeEvent].tirePressure2 <= 1.2
          && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp - a._2.asInstanceOf[MotorbikeEvent].currentTimestamp) < 5000 && (b._2.asInstanceOf[MotorbikeEvent].currentTimestamp > a._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
          && sc.parallelize(verticesBlowOutTire).filter(attr => attr.asInstanceOf[BlowOutTireEvent].currentTimestamp1 == a._2.asInstanceOf[MotorbikeEvent].currentTimestamp && attr.asInstanceOf[BlowOutTireEvent].currentTimestamp2 == b._2.asInstanceOf[MotorbikeEvent].currentTimestamp).count == 0) {
          val blowOutTireEvent = new BlowOutTireEvent(System.currentTimeMillis(), a._2.asInstanceOf[MotorbikeEvent].motorbikeId, b._2.asInstanceOf[MotorbikeEvent].location, a._2.asInstanceOf[MotorbikeEvent].tirePressure1, a._2.asInstanceOf[MotorbikeEvent].tirePressure2, b._2.asInstanceOf[MotorbikeEvent].location, b._2.asInstanceOf[MotorbikeEvent].tirePressure1, b._2.asInstanceOf[MotorbikeEvent].tirePressure2, a._2.asInstanceOf[MotorbikeEvent].currentTimestamp, b._2.asInstanceOf[MotorbikeEvent].currentTimestamp)
          logger.info(blowOutTireEvent.toString)
          result += blowOutTireEvent
        }
      }
    }

    return result
  }

  // ---------------- DRIVERLEFTSEAT ------------------

  def driverLeftSeat() {
    
    val dls = new DriverLeftSeatSubscriber(sc, graph)

    dls.driverLeftSeat()

  }

  // ---------------- OCCUPANTTHROWNACCIDENT ------------------

  def occupantThrownAccident() {
    val graphUnion = Graph(graphCrash.vertices.union(graphBlowOutTire.vertices.union(graphDriverLeftSeat.vertices)), graphCrash.edges.union(graphBlowOutTire.edges.union(graphDriverLeftSeat.edges)))
    val groupMotorbike = graphUnion.vertices.groupBy(attr => {
      if (attr._2.isInstanceOf[DriverLeftSeatEvent]) {
        attr._2.asInstanceOf[DriverLeftSeatEvent].motorbikeId
      } else if (attr._2.isInstanceOf[CrashEvent]) {
        attr._2.asInstanceOf[CrashEvent].motorbikeId
      } else if (attr._2.isInstanceOf[BlowOutTireEvent]) {
        attr._2.asInstanceOf[BlowOutTireEvent].motorbikeId
      }
    })

    val groupMotorbikeOrder = groupMotorbike.map(f => (f._1, f._2.toList.sortBy(f => f._2.asInstanceOf[VertexProperty].currentTimeStamp))).collect
    verticesOccupantThrownAccident = verticesOccupantThrownAccident ++ groupMotorbikeOrder.flatMap(f => isOccupantThrownAccident(f._2))
    val occupantThrownAccidentVertices = sc.parallelize(verticesOccupantThrownAccident).zipWithIndex().map(r => (r._2.asInstanceOf[VertexId], r._1))
    verticesOccupantThrownAccident = verticesOccupantThrownAccident.filter { attr => (System.currentTimeMillis() - attr.currentTimeStamp) <= 3000 } //TODO ventana
    graphOccupantThrownAccident = Graph(occupantThrownAccidentVertices, sc.parallelize(ListBuffer[Edge[(Integer, String, Long)]]()))
  }

  def isOccupantThrownAccident(list: List[(VertexId, VertexProperty)]): ListBuffer[(VertexProperty)] = {
    val logger: Logger = LoggerFactory.getLogger(this.getClass)
    var result = ListBuffer[(VertexProperty)]()
    for (a <- list; b <- list; c <- list) {
      if (a._2.isInstanceOf[BlowOutTireEvent]
        && b._2.isInstanceOf[CrashEvent]
        && c._2.isInstanceOf[DriverLeftSeatEvent]
        && a._2.asInstanceOf[VertexProperty].currentTimeStamp < b._2.asInstanceOf[VertexProperty].currentTimeStamp
        && b._2.asInstanceOf[VertexProperty].currentTimeStamp < c._2.asInstanceOf[VertexProperty].currentTimeStamp
        && (c._2.asInstanceOf[VertexProperty].currentTimeStamp - a._2.asInstanceOf[VertexProperty].currentTimeStamp) <= 3000
        && sc.parallelize(verticesOccupantThrownAccident).filter(attr => attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp1 == a._2.asInstanceOf[BlowOutTireEvent].timestamp && attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp2 == b._2.asInstanceOf[CrashEvent].timestamp && attr.asInstanceOf[OccupantThrownAccidentEvent].currentTimestamp3 == c._2.asInstanceOf[DriverLeftSeatEvent].timestamp).count == 0) {
        val occupantThrownAccidentEvent = new OccupantThrownAccidentEvent(System.currentTimeMillis(), c._2.asInstanceOf[DriverLeftSeatEvent].motorbikeId, c._2.asInstanceOf[DriverLeftSeatEvent].location, a._2.asInstanceOf[BlowOutTireEvent].timestamp, b._2.asInstanceOf[CrashEvent].timestamp, c._2.asInstanceOf[DriverLeftSeatEvent].timestamp)
        logger.info(occupantThrownAccidentEvent.toString)
        result += occupantThrownAccidentEvent

      }
    }

    return result
  }


}